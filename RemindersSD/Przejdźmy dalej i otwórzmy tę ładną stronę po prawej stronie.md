Przejdźmy dalej i otwórzmy tę ładną stronę po prawej stronie. Będziemy kontynuować pracę nad naszym klonem przypomnień z wykorzystaniem frameworka **Swift Data**. Więc kontynuujmy. W poprzednim wideo skonfigurowaliśmy bardzo podstawowy interfejs. Jak widać po prawej stronie, mamy ekran mojej listy, który zawiera kilka zakodowanych na stałe przypomnień lub list. Mogę otworzyć tę ładną stronę, która pozwala dodać nową listę. Obecnie niczego nie dodaje. Ma widok selektora, który jest selektorem koloru i tak dalej. Wygląda to naprawdę ładnie, ale nie robi zbyt wiele. Nie zapisuje danych do bazy danych. Musimy więc dowiedzieć się, jak możemy zapisać informacje za pomocą **Swift Data** do rzeczywistej bazy danych.

Aby to zrobić, pierwszą rzeczą, którą musimy zrobić, jest zacząć myśleć o modelach, które będziemy tworzyć. Stworzę nowy model. Musimy tworzyć modele, ponieważ to one będą zapisywane do bazy danych. Nazwę go **MyList**. Nie mogę nazwać go **List**, choć chciałbym, ponieważ w **Swift UI** jest już coś o nazwie **List**. Nazwę go więc **MyList**. Będzie to model używany przez **Swift Data**. Najpierw zaimportuję **Swift Data** i stworzę klasę o nazwie **MyList** oraz dodam makro modelu, które jest dostępne tylko dla klasy. Jeśli spróbujesz dodać makro modelu do struktury, nie zadziała to.

Dodam również model, który może mieć nazwę, na przykład lista może mieć nazwę jak zakupy, oraz jakiś kolor z nią związany. W poprzedniej wersji **Xcode** mogłem używać typów transformowalnych, które faktycznie zapisują typ w bazie danych, co było całkiem fajne. Niestety, obecnie to nie działa. Zamiast zapisywać typ transformowalny, zapiszę kod koloru, kod hex dla tego koloru. Kiedy Apple naprawi te problemy, zaktualizuję wideo o nową wersję, w której faktycznie używamy typów transformowalnych.

Stwórzmy konstruktor lub inicjalizator. Gotowe. Teraz mamy **MyList**. Ma nazwę i kod koloru. Aby działać z naszą aplikacją, warto poświęcić trochę czasu na podglądy lub fałszywy kontener, który jest dostępny tylko w podglądach. Teraz, jeśli spojrzę na ekran mojej listy, mogę dodać tutaj kontener modelu. Kontener modelu jest wymagany, jeśli używasz **Swift Data**. Chcę jednak dostarczyć kontener modelu, który ma już dodane listy, takie jak przypomnienia, zakupy, rozrywka.

Zaimportujmy **Swift Data**. Jak dostarczyć kontener podglądu? Dodam nowy plik w zawartości podglądu i nazwę go **PreviewContainer**. Będzie on dostępny tylko w podglądach. Dodanie kontenera podglądu ma na celu dostarczenie danych testowych podczas pracy z podglądami.

Zdefiniuję zmienną **previewContainer**, która zwróci kontener modelu. Wszystko wewnątrz będzie na głównym aktorze, inaczej nie będziemy mogli uzyskać dostępu do kontekstu. Stworzymy kontener, który będzie próbował stworzyć kontener modelu. Dla konfiguracji przekażemy typ modelu, który właśnie stworzyliśmy, czyli **MyList.self**. Konfiguracja pozwala określić, czy dane są przechowywane w pamięci. Ustawiam **true**, ponieważ pracuję z podglądami i nie chcę zapisywać danych do bazy danych. Jeśli mogą być przechowywane w pamięci, to też jest dobrze. Następnie zwrócimy kontener.

Używam tutaj wymuszonego **try** z wykrzyknikiem. Nie jest to duży problem, ponieważ kontener podglądu będzie używany tylko do podglądów. Jeśli wystąpi problem z konfiguracją kontenera modelu, podglądy się zawieszą.

Dodajmy przykładowe dane. Stworzyłem osobną strukturę o nazwie **SampleData**. Ma ona właściwość statyczną **myList**, która zwraca tablicę dwóch zakodowanych na stałe list: przypomnień i backlogu. Musimy jednak dodać te elementy do bazy danych. Użyję **sampleData.myList**, a następnie za pomocą **container.mainContext.insert** dodam listy do bazy danych. To oznacza, że jeśli użyję kontenera podglądu, powinienem automatycznie uzyskać te dwie listy, ponieważ je dodaję.

Wróćmy do ekranu mojej listy. Dla podglądów powinniśmy ustawić tutaj kontener modelu i przekazać kontener podglądu. Kontener podglądu jest oznaczony jako **main actor**, więc jest dostępny tylko na głównym aktorze. W podglądzie możemy również oznaczyć **main actor**, aby podgląd działał na głównym aktorze. Upewnijmy się, że tego używamy.

Teraz wiemy, że dostarczając kontener podglądu do naszej aplikacji, ten kontener zawiera również dwa elementy. Pamiętasz te elementy? To te, które dodajemy do kontenera. To oznacza, że mogę spróbować pobrać te elementy i wyświetlić je zamiast zakodowanej na stałe tablicy **myList**.

Zdefiniujmy zapytanie **myList**, które będzie typu **MyList**. Możemy usunąć tę część. Aby wyświetlić listę, nie potrzebujemy tutaj identyfikatora, ponieważ **MyList** ma już automatycznie utworzony identyfikator. **MyList** jest teraz klasą z właściwością **name**. Możemy to wykorzystać. Możemy użyć jednej z właściwości **name** i wyświetlić te elementy. Widać, że te dwa elementy pochodzą teraz z naszego kontenera podglądu. To całkiem fajne.

Następną rzeczą, którą chcemy zrobić, jest dodanie **MyList** do ekranu lub bazy danych. W funkcji **done** nie robimy nic. Zróbmy coś. Jeśli stworzę instancję **MyList**, potrzebujemy nazwy i kodu koloru. Nazwa jest prosta, ponieważ pochodzi z pola tekstowego, które możemy uzyskać przez **listName**. Kod koloru pochodzi z koloru, który jest typu **Color**. Nie mamy domyślnego sposobu na uzyskanie kodu koloru z typu **Color**. Musimy coś z tym zrobić.

Musimy również wstrzyknąć kontener modelu dla kontenera podglądu. Ustawmy **previewContainer**, który jest dostępny tylko na głównym aktorze. Musimy użyć **main actor**.

Problem polega na tym, że mamy wybrany kolor, który jest typu **Color**. Musimy go przekonwertować na kod hex. Jak to zrobić? Poprosiłem **ChatGPT** o kod, który pozwoli przekonwertować kolor na hex. Dodam nową grupę o nazwie **Extensions**, nowy plik, i będzie to rozszerzenie **Color**. Nazwę go **Color+Extensions**. Dodam rozszerzenie do **Color**, ale najpierw zaimportuję **SwiftUI**, ponieważ tam znajduje się **Color**. Dodam rozszerzenie **Color** i zaimplementuję funkcję **toHex**. Funkcja **toHex** będzie odpowiedzialna za konwersję koloru na hex.

Jeśli chcesz więcej szczegółów na temat tej funkcji, możesz wkleić ten kod w **ChatGPT** i dowiedzieć się więcej. Funkcja wyodrębnia wartości RGB i tworzy ciąg hex. Wróćmy i spróbujmy uzyskać kod hex. Ustawmy **hex** jako **color.toHex**, co zwróci opcjonalny ciąg, więc musimy go rozpakować. Teraz mogę przekazać **hex**.

Na koniec mogę powiedzieć **context**, do którego nie mamy dostępu. Przejdźmy na górę i uzyskajmy dostęp do kontekstu, który będzie typu **modelContext**, prywatna zmienna **context**. Wróćmy i powiedzmy **context.insert(myList)**. Po dodaniu możemy zamknąć widok.

Wróćmy do ekranu mojej listy i spróbujmy dodać nową listę. Mamy backlog, przypomnienia. Dodajmy zakupy. Zakupy, zielony kolor, i kliknijmy **done**. Zakupy zostały dodane. Ale to nie jest zielony kolor, to czarny. Musimy to naprawić.

Problem polega na tym, że podczas wyświetlania tych elementów nie określamy, że styl pierwszego planu pochodzi z **myList.color**. Mamy **myList.colorCode**. Musimy przekonwertować kod koloru na rzeczywisty kolor. Pokażę wam kod, który znalazłem na blogu Marco Edingera. Jest to naprawdę dobry artykuł o konwersji z hex na kolor i z powrotem w **SwiftUI**. Udostępnił kod, który wykorzystamy do konwersji koloru w hex na rzeczywisty kolor. To dokładnie to, czego potrzebujemy.

Dodajmy to do rozszerzeń koloru. Jeśli przekażemy ciąg hex, zainicjuje to nowy kolor. Wróćmy i możemy to zrobić tutaj. Ustawmy styl pierwszego planu na kolor z hex, czyli **myList.colorCode**. Przekazujemy kod koloru, a on zwraca kolor. Widać, że działa, ponieważ backlog jest fioletowy, a zakupy są zielone. Dodajmy jeszcze jedną listę. Nazwijmy ją rozrywka i dodajmy. Widać, że kolor jest czerwony. Wygląda na to, że wszystko działa. Wszystkie te elementy są teraz zapisywane do bazy danych. Jeśli uruchomisz to na rzeczywistym urządzeniu, zapisze dane do rzeczywistej bazy danych. Ale nie uruchamiaj teraz, ponieważ nie skończyliśmy jeszcze z klonem przypomnień.

Przejdźmy do pliku aplikacji, zamiast używać **ContentView**, możemy go usunąć. Nie będziemy używać **ContentView**. Usuńmy go. Nasz ekran główny nazywa się **MyListScreen**. Używamy **NavigationStack**. Będziemy używać kontenera modelu, ale nie kontenera podglądu, ponieważ to jest rzeczywista aplikacja. Ustawmy **MyList.self**. To powinno wystarczyć do uruchomienia na rzeczywistym urządzeniu. Uruchommy to. Kiedy zapisuje informacje, będą one zapisane do rzeczywistej bazy danych.

Dodajmy przypomnienia. Gotowe. Dodajmy zakupy. Mamy zakupy. Zatrzymajmy aplikację i uruchommy ponownie. Przypomnienia i zakupy są zapisane.

W tym wideo nauczyłeś się, jak zapisywać do rzeczywistej bazy danych za pomocą **Swift Data** i jak wyświetlać dane na ekranie. Mam nadzieję, że podobało się. W następnym wideo będziemy kontynuować pracę nad klonem przypomnień. Dziękuję za oglądanie.